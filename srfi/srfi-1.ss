(define (xcons d a)
  (cons d a))

(define (make-list n el)
  (check-parameter n number? make-list)
  (if (= n 0)
    '()
    (cons el (make-list (- n 1) el))))

(define (list-tabulate n proc)
  (check-parameter n number? list-tabulate)
  (check-parameter proc procedure? list-tabulate)
  (define (go j)
    (if (= j n)
      '()
      (cons (proc j)
            (go (+ 1 j)))))
  (go 0))

(define (list? xs)
  (or (null? xs)
      (and (pair? xs)
           (list? (cdr xs)))))

(define (list-copy xs)
  (check-parameter xs list? list-tabulate)
  (if (null? xs)
    '()
    (cons (car xs) (list-copy (cdr xs)))))

(define (dotted-list? xs)
  (cond
    ((null? xs) #f)
    ((pair? xs) (dotted-list? (cdr xs)))
    (else #t)))

(define (list= elt= . rest)
  (check-parameter elt= procedure? list=)
  (define (lists-equal a b)
    (or (and (null? a) (null? b))
        (and (pair? a) (pair? b)
             (elt= (car a) (car b))
             (lists-equal (cdr a) (cdr b)))))
  (define (lp l)
    (or (null? (cdr l))
        (and (lists-equal (cdr l) (cadr l))
             (lp (cdr l)))))
  (or (null? rest)
      (lp rest)))

(define (list-ref xs i)
  (check-parameter xs list? list-ref)
  (check-parameter i number? list-ref)
  (cond
    ((null? xs) (error "list-ref: index out of range"))
    ((= i 0) (car xs))
    (else (list-ref (cdr xs) (- i 1)))))


(define (car+cdr p)
  (values (car p) (cdr p)))

(define (any1 pred ls)
  (check-parameter pred procedure? any1)
  (check-parameter ls list? any1)
  (cond ((null? ls) #f)
        (else (or (pred (car ls))
                  (any1 pred (cdr ls))))))

(define (fold1 k z l)
  (if (null? l)
    z
    (k (car l) (fold1 k z (cdr l)))))

(define map
  (case-lambda
    ((f l) ; map
     (check-parameter f procedure? map)
     (let go ((l l))
       (if (null? l)
         '()
         (cons (f (car l))
               (map f (cdr l))))))
    ((f l1 l2) ; zipWith
     (check-parameter f procedure? map)
     (let go ((l1 l1) (l2 l2))
       (cond
         ((null? l1) '())
         ((null? l2) '())
         (else (cons (f (car l1) (car l2))
                     (go (cdr l2) (cdr l2)))))))
    ((f l1 . ls)
     (check-parameter f procedure? map)
     (define len (fold1 (lambda (ls len)
                          (min (length ls) len))
                        (length l1)
                        ls))
     (let go ((l1 l1) (rest rest) (len len))
       (if (= len 0)
         '()
         (cons (apply f (cons (car l1) (map car rest)))
               (go (cdr l1) (map cdr rest) (- len 1))))))))

(define cons*
  (case-lambda
    (() '())
    ((x y) (cons x y))
    ((x y . r) (cons x (apply cons* (cons y r))))))

(define (iota count . r)
  (define start (if (pair? r) (car r) 0))
  (define step (if (pair? (cdr r)) (cadr r) 1))
  (check-parameter count number? iota)
  (let go ((n 0))
    (if (= n count)
      '()
      (cons (+ start (* step n))
            (go (+ 1 n))))))

(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))

(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (car x)))))

(define first car)
(define second cadr)
(define third caddr)
(define fourth cadddr)
(define (fifth x) (car (cddddr x)))
(define (sixth x) (cadr (cddddr x)))
(define (seventh x) (caddr (cddddr x)))
(define (eighth x) (cadddr (cddddr x)))
(define (ninth x) (car (cddddr (cddddr x))))
(define (tenth x) (cadr (cddddr (cddddr x))))

(define (take x i)
  (check-parameter x list? take)
  (check-parameter i number? take)
  (cond
    ((<= 0 i) '())
    ((null? x) '())
    ((pair? x)
     (cons (car x)
           (take (cdr x) (- i 1))))))

(define (drop x i)
  (check-parameter x list? drop)
  (check-parameter i number? drop)
  (cond
    ((<= 0 i) x)
    ((null? x) '())
    (else (drop (cdr x) (- 1 i)))))

(define (zip . ls)
  (apply map (cons list ls)))

(define (reverse l)
  (define (go acc l)
    (if (null? l)
      acc
      (go (cons (car l) acc)
          (cdr l))))
  (go '() l))
